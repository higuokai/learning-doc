### HashMap、HashTable、ConcurrentHashMap

***

1. #### HashMap

   1. ##### HashMap数据结构

      ​		HashMap底层是一个数组，JDK1.7中，数组的桶内是一个链表； JDK1.8中，数组桶内是链表，链表在一些条件下会转换为一个红黑树(满足2个条件才转换)。
      
      ​		HashMap的默认数组长度为16，默认负载因子为0.75，元素到达一定长度时，会对数组进行扩容(默认扩容长度为16*0.75=12), 扩容为原来的2倍。
      
   1. ##### HashMap寻址主要体现在put()方法（JDK1.8）：
   
      1. 如果数组没有初始化，进行初始化，扩容；
      2. key的hash值(Object.hashCode()方法)右移16位与hash值本身取异或运算，然后对数组长度进项取模，取模结果就是key对应在数组中的索引。
      3. 如果key在桶内链表中存在，直接进行覆盖value值。
      4. 如果不存在，JDK1.7中，因为桶内元素总是链表，直接用头插法将元素放入链表头部，并将当前元素置为数组元素；在JDK1.8中，会判断桶内元素长度是否大于8， 如果大于8且数组长度大于64则变为红黑树，大于8小于64会进行扩容。
      5. 设置完数据后，会判断容量是不是大于   数组长度*负载因子(默认16 * 0.75=12)，如果大于会进行扩容，扩容为原先的2倍。
      6. 扩容时hash值的计算会使用扰动函数，然后 按位与 length-1，来代替直接对数组长度进行取模运算，得到数组的下标索引，来存放值。
      
   3. ##### 为什么HashMap扩容时原先的2倍（大小为2的N次方）
   
      ​		HashMap的主要数据结构是数组。存储时，要根据key的hashCode定位到数组的下标索引，方法就是使用hash对数组长度取模，取模结果就是数组索引。
   
      ​		HashMap中 使用  按位与(&) 的方式来进行取模运算: 
   
      ​		x%2^n = x & (2^n -1)， 一个数对2的N次方取模，等同于 对2的N次方-1做按位与运算。
   
      ​		设n为3, 则2^3-1=7， 二进制表示为 0111。此时 x&(2^3 -1)相当于取x的二进制的后三位。从二进制角度看，x / 8 相当于 x >> 3, x右移3位即丢弃后三位，结果为x除以8的商, 丢掉的3位就是余数(x%8)。 要取后三位结果， x & (0111)即可，  0111 表现为10进制就是 8 - 1， 0111中1前面全是0， 与任何数与都为0。与运算比取模快，所以 x & (2^n -1) 来替代 x % 2^n。
   
   4. ##### HashMap中hash()函数
   
      ​	为了使取模结果更离散，需要对hashCode进行扰动计算。
   
      ​	假如数组长度为16, 15扩展到二进制为 0000 0000 0000 0000 0000 0000 0000 1111, 如果两个数的高位不同, 低位相同,两个数对15按位与运算结果是一样的，造成hash冲突。
   
      ​	JDK1.7中扰动算法: 4次按位运算与5次异或运算
   
      ~~~java
      h ^= k.hashCode();
      h ^= (h >>> 20) ^ (h >>> 12);
      return h ^ (h >>> 7) ^ (h >>> 4);
      ~~~
   
      ​	JDK1.8对扰动函数进行了优化，hash值右移16位 异或 hash值本身， 无符号右移16位变成正数，将高16信息变为低16位，使高16位元素与低16位元素异或，原高16位元素与填充的0异或，取模运算更离散。
   
      ​	使用异或是因为: 按位或(|)的结果向1靠拢, 10 11 01都等于1, 按位与(&)的结果向0靠拢 10 01 00 都为0,   异或时, 1和0各50%，哈希结果更散列。
   
   5. ##### HashMap容量初始化
   
      初始化算法:
   
      ```java
      static final int tableSizeFor(int cap) {
              int n = cap - 1;
              n |= n >>> 1;
              n |= n >>> 2;
              n |= n >>> 4;
              n |= n >>> 8;
              n |= n >>> 16;
              return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
       }
      ```
   
      给定hashMap大小时, 取比给定大小大的最小的2的N次方数  3->4  5->8 6->8 . . .
   
      方法: 将给定数字二进制第一个不为0的比特位开始往后所有比特位都设置为1, 即 0000 1111 + 1 = 15   + 1 = 16
   
      原理:
   
      ​	0000 1000
   
      ​	n |= n >>> 1   第一个不为1的数右移, 与之前数或  0000 1100
   
      ​	n |= n >>> 2  上一步两个不为1的数右移2, 与之前取 或 , 0000 1111
   
      ​	...
   
      ​	最后 n |= n >>> 16, 即可将从第一个不为1开始往后的置为1, 得到数字为 2^n-1,  加一可得最终结果 2^n
   
      ​	0100 0000
      ​	0110 0000	n |= n >>> 1
      ​	0111 1000	n |= n >>> 2
      ​	0111 1111	n |= n >>> 4
      ​	0111 1111	n |= n >>> 8
      ​	0111 1111	n |= n >>> 16 一共移位31位, 等于int大小
   
      符号位0为正, 1为负
   
   6. ##### HashMap   JDK1.7中形成闭环原因
   
      JDK1.7时，头插法扩容会将元素顺序翻转，A -> B -> null  扩容后  B -> A -> null；
   
      ```java
      void transfer(Entry[] newTable, boolean rehash) {
              int newCapacity = newTable.length;
              for (Entry<K,V> e : table) {
                  while(null != e) {
                      Entry<K,V> next = e.next;
                      if (rehash) {
                          e.hash = null == e.key ? 0 : hash(e.key);
                      }
                      int i = indexFor(e.hash, newCapacity);
                      e.next = newTable[i];
                      newTable[i] = e;
                      e = next;
                  }
              }
          }
      ```
   
      两个线程同时操作时，假设A、B元素扩容后还在同一个桶位。
   
       	1. 线程t1进入方法， 内存已开辟, 还未执行替换，这时 e = A,  next = B。
       	2. 线程t2进入扩容方法，将链表顺序变为B->A->null。
       	3. 线程t1继续执行， 将元素A放入链表头，会覆盖原该桶位元素，变成 A->null，再次循环 e = B；
       	4. 线程t1执行，将B放入链表头， 变成B->A->null，正常应该停止（B.next=null），但是t2将链表已经翻转，此时B.next = A, 又执行A；
       	5. 此时A.next = null，将A放入链表头，表头的B被设置为A.next, 形成A->B->A，因为next=null，退出循环，形成闭环，查询时死循环。
   
   7. ##### 迭代
   
      HashMap迭代是fail-fast，内部维护一个modCount，当涉及hashMap结构变化(包括put新元素，不包括put时替换旧元素)时，会增加modCount值，迭代时会检查modCount值是否变化，变化后抛出异常。
   
   8. 22
   
***

   2. #### HashTable
   
      1. ##### 初始化
      
         ​	HashTable容量初始化为11，扩容时容量为  size << 1 + 1， 都是奇数。使用的是头插法，因为加锁，没有多线程操作，没有安全问题。
      
      2. ##### hash函数
      
         HashTable中, 使用的是   int index = (hash & 0x7FFFFFFF) % tab.length;  直接用hash码对长度进项取模, 没有使用位运算(与0x7FFFFFFF是为了将第一位变成0, 将数变成正数)
      
         HashTable取模运算肯定比位运算效率低，默认初始化大小为11，扩容为原来的2n+1，为奇数，hash值对奇数取模运算结果更均匀。HashMap为了快使用位运算代替取模，但是取模会导致哈希分布不均匀为题，对hash算法做了扰动运算。

***

   3. #### ConcurrentHashMap

      1. ##### JDK1.7

         ​	JDK1.7中，数据结构是两层HashMap结构的嵌套。外部是一个Segment数组，Segment对象内也维护一个HashEntry数组。默认大小为16，负载因子0.75。

          Segment对象继承ReentrantLock可重入锁。 最大支持默认16的个(Segment数组长度)线程同时操作。最大的并发数是初始化时Segment的数组长度。

      2. ##### JDK1.8

         JDK1.8取消了分段锁Segment的设计，底层使用数组+单向链表+红黑树的结构，与HashMap更接近。

         通过 synchronized + CAS 锁定链表/树头部元素来锁定整行数据。并发数为数组长度。

         1. put时如果数组未初始化, 进行table初始化，初始化时采用CAS+自旋的方式保证只有一个线程可以初始化成功数据，其余线程自旋等待初始化完成。
         2. put自旋如果所在桶位第一个元素为空，CAS设置本身为头部元素，如果成功退出自旋，失败进入下一次自旋。
         3. 对头部元素synchronized锁，执行插入操作，类似HashMap，会变化成红黑树等操作。

      3. other


   ​	

   